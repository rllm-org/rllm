"""
Remote Episode Collector for Remote Agent Support.

Replaces the local ``UnifiedWorkflowEngine`` when episodes are generated by
remote agents running in Docker containers or external runtimes.  Exposes the
same ``execute_tasks()`` interface so that existing backends (Tinker, Verl)
can use it as a drop-in replacement.

Protocol
--------
For each task the collector sends an HTTP POST to a remote agent endpoint:

    POST /generate_episode
    {
        "task":              dict,   # task specification
        "task_id":           str,    # unique task identifier
        "rollout_idx":       int,    # rollout index within the group
        "inference_api_url": str,    # URL of trainer's inference API
        "is_validation":     bool,   # whether this is a validation rollout
        "config":            dict    # optional extra config
    }

The remote agent responds with:

    { "episode": <Episode.to_dict()> }
"""

from __future__ import annotations

import asyncio
import logging
import uuid
from collections import defaultdict
from dataclasses import dataclass, field

import httpx
from tqdm import tqdm

from rllm.agents.agent import Episode
from rllm.workflows.workflow import TerminationReason

logger = logging.getLogger(__name__)


@dataclass
class RemoteCollectorConfig:
    """Configuration for the RemoteEpisodeCollector."""

    endpoints: list[str] = field(default_factory=list)
    inference_api_url: str = ""
    timeout: float = 600.0  # per-request timeout in seconds
    max_concurrent: int = 128  # max concurrent requests
    retry_limit: int = 3
    extra_config: dict = field(default_factory=dict)


class RemoteEpisodeCollector:
    """Collects episodes from remote agent endpoints via HTTP.

    This class mirrors the ``execute_tasks`` interface of
    ``UnifiedWorkflowEngine`` so it can be used as a drop-in replacement
    when remote agent mode is enabled.

    Usage::

        collector = RemoteEpisodeCollector(config)
        episodes = await collector.execute_tasks(tasks, task_ids, is_validation=False)
    """

    def __init__(self, config: RemoteCollectorConfig):
        self.config = config
        self.endpoints = config.endpoints
        if not self.endpoints:
            raise ValueError("At least one remote agent endpoint must be configured")

        self._client = httpx.AsyncClient(
            limits=httpx.Limits(
                max_connections=config.max_concurrent,
                max_keepalive_connections=min(config.max_concurrent, 200),
            ),
            timeout=httpx.Timeout(config.timeout),
        )
        self._endpoint_idx = 0  # round-robin counter

        # These mirror UnifiedWorkflowEngine's attributes for compatibility
        self.current_step = 0
        self.current_epoch = 0
        self.current_mode = "train"
        self.episode_logger = None  # can be set by the trainer

    def set_training_step(self, step: int, mode: str = "train", epoch: int = 0):
        """Set current training step (mirrors UnifiedWorkflowEngine API)."""
        self.current_step = step
        self.current_mode = mode
        self.current_epoch = epoch

    # ------------------------------------------------------------------
    # Core interface
    # ------------------------------------------------------------------

    async def execute_tasks(
        self,
        tasks: list[dict],
        task_ids: list[str] | None = None,
        is_validation: bool = False,
        **kwargs,
    ) -> list[Episode]:
        """Execute tasks by dispatching them to remote agent endpoints.

        Args:
            tasks: List of task dictionaries to process.
            task_ids: Optional list of task identifiers. If *None*, UUIDs are
                generated.
            is_validation: Whether the generation is for validation.
            **kwargs: Extra arguments (ignored, kept for interface compat).

        Returns:
            Ordered list of Episode objects, one per input task.
        """
        if task_ids is None:
            task_ids = [str(uuid.uuid4()) for _ in tasks]

        # Compute per-task rollout indices (same logic as UnifiedWorkflowEngine)
        task_id_counter: dict[str, int] = defaultdict(int)
        results: list[Episode | None] = [None] * len(tasks)

        semaphore = asyncio.Semaphore(self.config.max_concurrent)

        async def _dispatch(idx: int, task: dict, task_id: str, rollout_idx: int):
            async with semaphore:
                episode = await self._call_remote_agent(
                    task=task,
                    task_id=task_id,
                    rollout_idx=rollout_idx,
                    is_validation=is_validation,
                )
                results[idx] = episode

        futures = []
        for idx, (task, task_id) in enumerate(zip(tasks, task_ids, strict=True)):
            rollout_idx = task_id_counter[task_id]
            task_id_counter[task_id] += 1
            futures.append(_dispatch(idx, task, task_id, rollout_idx))

        # Run all dispatches concurrently with a progress bar
        with tqdm(total=len(tasks), desc="Collecting remote episodes") as pbar:
            for coro in asyncio.as_completed(futures):
                await coro
                pbar.update(1)

        # All slots must be filled
        ordered_results: list[Episode] = results  # type: ignore[assignment]

        # Log episodes if logger is provided (same as UnifiedWorkflowEngine)
        if self.episode_logger is not None:
            try:
                logger.info(f"Logging {len(ordered_results)} episodes to step={self.current_step}, mode={self.current_mode}, epoch={self.current_epoch}")
                self.episode_logger.log_episodes_batch(
                    ordered_results,
                    self.current_step,
                    self.current_mode,
                    self.current_epoch,
                )
            except Exception as e:
                logger.error(f"Failed to log episodes: {e}")

        return ordered_results

    # ------------------------------------------------------------------
    # HTTP dispatch
    # ------------------------------------------------------------------

    def _pick_endpoint(self) -> str:
        """Round-robin endpoint selection."""
        endpoint = self.endpoints[self._endpoint_idx % len(self.endpoints)]
        self._endpoint_idx += 1
        return endpoint

    async def _call_remote_agent(
        self,
        task: dict,
        task_id: str,
        rollout_idx: int,
        is_validation: bool,
    ) -> Episode:
        """Send a single task to a remote agent and return the Episode.

        Retries up to ``config.retry_limit`` times on failure.
        """
        payload = {
            "task": task,
            "task_id": task_id,
            "rollout_idx": rollout_idx,
            "inference_api_url": self.config.inference_api_url,
            "is_validation": is_validation,
            "config": self.config.extra_config,
        }

        last_error: Exception | None = None
        for attempt in range(1, self.config.retry_limit + 1):
            endpoint = self._pick_endpoint()
            url = f"{endpoint.rstrip('/')}/generate_episode"
            try:
                response = await self._client.post(url, json=payload)
                response.raise_for_status()
                data = response.json()
                episode = Episode.from_dict(data["episode"])
                return episode
            except Exception as e:
                last_error = e
                logger.warning(f"[{task_id}:{rollout_idx}] Remote agent call failed (attempt {attempt}/{self.config.retry_limit}): {e}")
                if attempt < self.config.retry_limit:
                    await asyncio.sleep(min(2**attempt, 10))

        # All retries exhausted â€” return an error episode
        logger.error(f"[{task_id}:{rollout_idx}] Remote agent failed permanently after {self.config.retry_limit} attempts: {last_error}")
        return self._make_error_episode(task_id, rollout_idx, task, last_error)

    @staticmethod
    def _make_error_episode(
        task_id: str,
        rollout_idx: int,
        task: dict,
        error: Exception | None,
    ) -> Episode:
        """Create a placeholder Episode for a permanently failed remote call."""
        return Episode(
            id=f"{task_id}:{rollout_idx}",
            task=task,
            termination_reason=TerminationReason.ERROR,
            is_correct=False,
            trajectories=[],
            metrics={},
            info={"error": {"message": str(error) if error else "unknown error"}},
        )

    # ------------------------------------------------------------------
    # Lifecycle
    # ------------------------------------------------------------------

    def shutdown(self):
        """Close the underlying HTTP client."""
        try:
            asyncio.get_event_loop().run_until_complete(self._client.aclose())
        except Exception:
            pass  # best-effort cleanup
